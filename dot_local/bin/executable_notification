#!/usr/bin/env bash
# Unified Claude Code notification script

set -e

# Get available system sounds
get_available_sounds() {
    local sounds_dir="/System/Library/Sounds"
    local user_sounds_dir="$HOME/Library/Sounds"
    local sounds=()
    
    # System sounds
    if [[ -d "$sounds_dir" ]]; then
        while IFS= read -r -d '' file; do
            sounds+=("$(basename "$file" .aiff)")
        done < <(find "$sounds_dir" -name "*.aiff" -print0 2>/dev/null)
    fi
    
    # User sounds
    if [[ -d "$user_sounds_dir" ]]; then
        while IFS= read -r -d '' file; do
            sounds+=("$(basename "$file" .aiff)")
        done < <(find "$user_sounds_dir" -name "*.aiff" -print0 2>/dev/null)
    fi
    
    printf '%s\n' "${sounds[@]}" | sort -u
}

usage() {
    echo "Usage: $0 TITLE [OPTIONS]"
    echo ""
    echo "Arguments:"
    echo "  TITLE                Notification title (required, first argument)"
    echo ""
    echo "Options:"
    echo "  -s, --subtitle TEXT  Notification subtitle"
    echo "  -m, --message TEXT   Notification message"
    echo "  -S, --sound SOUND    Notification sound"
    echo "  -a, --activate ID    App to activate on click"
    echo "  -h, --help           Show this help message"
    echo ""
    echo "Available sounds:"
    local available_sounds=($(get_available_sounds))
    if [[ ${#available_sounds[@]} -gt 0 ]]; then
        printf '  %s\n' "${available_sounds[@]}"
    else
        echo "  No sounds found"
    fi
    exit 1
}

# Parse command line arguments
if [[ $# -eq 0 ]]; then
    echo "Error: TITLE is required"
    usage
fi

TITLE="$1"
shift

SUBTITLE=""
MESSAGE=""
SOUND=""
ACTIVATE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--subtitle)
            SUBTITLE="$2"
            shift 2
            ;;
        -m|--message)
            MESSAGE="$2"
            shift 2
            ;;
        -S|--sound)
            SOUND="$2"
            shift 2
            ;;
        -a|--activate)
            ACTIVATE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Validate sound if provided
if [[ -n "$SOUND" ]]; then
    available_sounds=($(get_available_sounds))
    sound_valid=false
    for available_sound in "${available_sounds[@]}"; do
        if [[ "$SOUND" == "$available_sound" ]]; then
            sound_valid=true
            break
        fi
    done
    
    if [[ "$sound_valid" == false ]]; then
        echo "Error: Sound '$SOUND' is not available."
        echo "Available sounds:"
        printf '  %s\n' "${available_sounds[@]}"
        exit 1
    fi
fi

# Check if Ghostty is the frontmost application
frontmost_app=$(osascript -e 'tell application "System Events" to get name of first application process whose frontmost is true' 2>/dev/null || echo "")

# Auto-set sound based on frontmost app if not explicitly provided
if [[ -z "$SOUND" && "$frontmost_app" != "ghostty" ]]; then
    SOUND="Hero"
fi

# Function to send notification via terminal-notifier
send_via_terminal_notifier() {
    local cmd=("terminal-notifier" "-title" "$TITLE")
    
    [[ -n "$SUBTITLE" ]] && cmd+=("-subtitle" "$SUBTITLE")
    [[ -n "$MESSAGE" ]] && cmd+=("-message" "$MESSAGE")
    [[ -n "$SOUND" ]] && cmd+=("-sound" "$SOUND")
    [[ -n "$ACTIVATE" ]] && cmd+=("-activate" "$ACTIVATE")
    
    "${cmd[@]}"
}

# Function to send notification via osascript (fallback)
send_via_osascript() {
    local notification_text="$TITLE"
    [[ -n "$SUBTITLE" ]] && notification_text="$notification_text - $SUBTITLE"
    [[ -n "$MESSAGE" ]] && notification_text="$notification_text: $MESSAGE"
    
    local script="display notification \"$notification_text\""
    [[ -n "$SOUND" ]] && script="$script sound name \"$SOUND\""
    
    osascript -e "$script"
}

# Try terminal-notifier first, fallback to osascript
if command -v terminal-notifier >/dev/null 2>&1; then
    send_via_terminal_notifier
else
    send_via_osascript
fi